{
  "model": {
    "default": "LibraxisAI/Bielik-11B-v3.0-mlx-q4",
    "base_url": "http://localhost:8011"
  },

  "agents": {
    "analytical": {
      "max_tokens": 800,
      "temperature": 0.2
    },
    "executor": {
      "max_tokens": 1500,
      "temperature": 0.2
    },
    "summary": {
      "max_tokens": 1200,
      "temperature": 0.2
    }
  },

  "analytical": "Zaplanuj rozwiazanie zadania matematycznego. Napisz KROTKI plan w maksymalnie 10 linijkach.\n\nZAKAZY:\n- ZAKAZANE: $, $$, \\frac, \\sqrt, \\left, \\right, \\cdot, \\(, \\), \\[, \\], \\boxed, \\dfrac\n- ZAKAZANE: wykonywanie obliczen, podstawianie wartosci, rozwiazywanie - to zrobi nastepny agent\n- ZAKAZANE: pisanie \"Krok 1\", \"Krok 2\" itd. z obliczeniami\n- Zamiast LaTeX: x**2, a/b, sqrt(x)\n- KROTKO: kazdy punkt planu to JEDNO zdanie\n\nFORMAT:\n\nAnaliza: [co mamy, czego szukamy - max 2 zdania]\nOznaczenia: [zmienne]\nPlan:\n1. [co zrobic - bez obliczen]\n2. [co zrobic]\n3. [co zrobic]\nRodzaj: [obliczenia/optymalizacja/dowod]\nSzukamy: [czego]\n\nWAZNE: Napisz TYLKO plan. NIE obliczaj, NIE podstawiaj, NIE rozwiazuj.",

  "executor_sympy": "Napisz JEDEN blok kodu Python/SymPy rozwiazujacy to zadanie.\n\nREGULY:\n- Potegowanie: x**2 (NIE x^2)\n- Mnozenie: 2*a (NIE 2a)\n- Ulamki: Rational(2,3) lub S(2)/3\n- Rownania: Eq(lewa, prawa) - NIGDY NIE uzywaj ==\n- NIE pisz assert\n- Ostatnia linia: print(\"ODPOWIEDZ:\", wynik)\n\nPRZYKLAD 1 (rownanie):\n```python\nfrom sympy import symbols, solve, Rational\nx = symbols('x')\nwynik = solve(Rational(3,2)*x - 1, x)\nprint(\"ODPOWIEDZ:\", wynik)\n```\n\nPRZYKLAD 2 (system rownan z Eq):\n```python\nfrom sympy import symbols, solve, Eq\na, h = symbols('a h', positive=True, real=True)\neq1 = Eq(a**2 * h, 108)\neq2 = Eq(h, 4*a)\nwynik = solve([eq1, eq2], [a, h])\nprint(\"ODPOWIEDZ:\", wynik)\n```\n\nPRZYKLAD 3 (uproszczenie wyrazenia):\n```python\nfrom sympy import symbols, expand, simplify\na, b = symbols('a b')\nexpr = (2*a + b)**2 - (2*a - b)**2\nwynik = expand(expr)\nprint(\"ODPOWIEDZ:\", wynik)\n```\n\nPRZYKLAD 4 (optymalizacja):\n```python\nfrom sympy import symbols, solve, diff, simplify\nx = symbols('x')\nf = -x**2 + 4*x\ndf = diff(f, x)\nx_max = solve(df, x)[0]\nwynik = simplify(f.subs(x, x_max))\nprint(\"ODPOWIEDZ:\", wynik)\n```\n\nWAZNE:\n- NIGDY nie uzywaj == do tworzenia rownan (to jest blad!)\n- Uzywaj Eq(lewa, prawa) lub po prostu wyrazenie = 0\n- Importuj Eq jesli go uzywasz: from sympy import Eq\n\nNapisz TYLKO:\nObliczam rozwiazanie:\n```python\n[kod]\n```\n\nNic wiecej. Zadnego tekstu po kodzie.",

  "executor_lean": "Napisz dowod w jezyku Lean 4.\n\nREGULY:\n- Napisz TYLKO kod Lean w bloku ```lean\n- Importuj Mathlib jesli potrzebne\n- Uzyj 'sorry' dla nietrywialnych krokow\n- Format: theorem nazwa : teza := by taktyki\n\nPRZYKLAD (indukcja):\n```lean\nimport Mathlib.Data.Nat.Basic\nimport Mathlib.Algebra.BigOperators.Basic\n\ntheorem sum_first_n (n : ℕ) :\n  (Finset.range (n + 1)).sum id = n * (n + 1) / 2 := by\n  induction n with\n  | zero => simp\n  | succ k ih =>\n    rw [Finset.sum_range_succ]\n    rw [ih]\n    ring\n```\n\nPRZYKLAD (proste twierdzenie):\n```lean\ntheorem add_comm (a b : ℕ) : a + b = b + a := by\n  ring\n```\n\nNapisz TYLKO:\n```lean\n[kod]\n```\n\nNic wiecej.",

  "summary": "Opisz rozwiazanie zadania krok po kroku po polsku. Przepisz wyniki z kodu. NIE licz sam.\n\nPRZYKLAD (dla innego zadania):\nZadanie: Oblicz pole kola o promieniu 5.\nWyniki kodu: Pole = 25*pi\n\nRozwiazanie krok po kroku:\n\nKrok 1: Ustalamy dane zadania.\nPromien kola wynosi r = 5.\n\nKrok 2: Stosujemy wzor na pole kola.\nPole = pi * r**2 = pi * 25.\n\nKrok 3: Obliczamy wartosc.\nPole = 25*pi.\n\nODPOWIEDZ: 25*pi\n\nKONIEC PRZYKLADU.\n\nTeraz opisz rozwiazanie powyzszego zadania w TAKIM SAMYM formacie. Napisz \"Rozwiazanie krok po kroku:\", potem kroki z wynikami z kodu, potem \"ODPOWIEDZ:\" z koncowym wynikiem."
}
