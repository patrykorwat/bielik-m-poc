{
  "model": {
    "default": "LibraxisAI/Bielik-11B-v3.0-mlx-q4",
    "base_url": "http://localhost:8011"
  },

  "agents": {
    "analytical": {
      "max_tokens": 800,
      "temperature": 0.2
    },
    "executor": {
      "max_tokens": 1200,
      "temperature": 0.2
    },
    "summary": {
      "max_tokens": 1000,
      "temperature": 0.2
    },
    "formalizer": {
      "max_tokens": 1500,
      "temperature": 0.1
    }
  },

  "analytical": "Przeanalizuj zadanie i przedstaw szczegolowy plan rozwiazania.\n\nZAKAZY:\n- ZAKAZANE: $, $$, \\frac, \\sqrt, \\left, \\right, \\cdot, \\(, \\), \\[, \\], \\boxed, \\dfrac\n- Zamiast LaTeX: x**2, a/b, sqrt(x)\n\nFORMAT:\n\nAnaliza problemu:\n[Szczegolowa analiza - co wiemy, co szukamy, jakie warunki mamy]\n\nOznaczenia:\n[Wprowadz zmienne i wyjasnij co oznaczaja]\n\nRozumowanie:\n[Opisz logiczny proces myslowy - jak podejsc do problemu, jakie zwiazki miedzy danymi zauważasz, jakie wnioski mozna wyciagnac PRZED obliczeniami]\n\nPlan obliczen:\n1. [szczegolowy krok z uzasadnieniem]\n2. [szczegolowy krok z uzasadnieniem]\n3. [szczegolowy krok z uzasadnieniem]\n...\n\nRodzaj: [obliczenia/dowod/optymalizacja/kombinatoryka/geometria]\nMetoda: [sympy/lean]\nOczekiwany wynik: [czego szukamy]\n\nPRZYKLAD:\nAnaliza problemu:\nMamy trojkat wpisany w okrag o promieniu R. Obwod wynosi 3R, a jeden bok jest dwukrotnie dluzszy od drugiego. Szukamy trojkata o maksymalnym polu.\n\nOznaczenia:\na, b, c - boki trojkata\nR - promien okregu opisanego\nP - pole trojkata\n\nRozumowanie:\nZ warunku c = 2a i obwodu a + b + c = 3R mozemy wyrazic b przez a i R.\nNastepnie nierownoci trojkata dadzą nam przedzial wartosci dla a.\nPole obliczymy wzorem Herona, a maksimum znajdziemy badajac funkcje P(a).\n\nPlan obliczen:\n1. Z warunku obwodu wyznacz b = 3R - 3a (podstaw c = 2a)\n2. Z nierownoci trojkata wyznacz przedzial dla a: R/2 < a < 3R/4\n3. Oblicz pole wzorem Herona: P = sqrt(s(s-a)(s-b)(s-c)) gdzie s = 3R/2\n4. Znajdz maksimum funkcji P(a) (pochodna lub podstawienie brzegowe)\n5. Oblicz pole maksymalne\n\nRodzaj: optymalizacja\nMetoda: sympy\nOczekiwany wynik: maksymalne pole trojkata\n\nWAZNE: Opisz PROCES MYSLOWY, nie tylko co zrobic, ale DLACZEGO.",

  "executor_sympy": "Napisz KOD Python/SymPy z KOMENTARZAMI wyjaśniającymi każdy krok.\n\nREGULY:\n- x**2 (NIE x^2)\n- 2*a (NIE 2a)\n- Eq(lewa, prawa) - NIGDY ==\n- Dodaj komentarze # wyjaśniające DLACZEGO robisz dany krok\n- Wypisuj wyniki pośrednie z print()\n- Na końcu print(\"ODPOWIEDZ:\", wynik_koncowy)\n\nPRZYKLAD:\n```python\nfrom sympy import symbols, solve, Eq, sqrt\n\n# Definiujemy zmienne: a - bok krotszy, R - promien okręgu\na, R = symbols('a R', positive=True, real=True)\n\n# Z warunku: c = 2a oraz obwod a + b + c = 3R\n# Podstawiamy c = 2a: a + b + 2a = 3R\n# Stąd: b = 3R - 3a\nb = 3*R - 3*a\nprint(\"Wyrazenie dla b:\", b)\n\n# Polowa obwodu dla wzoru Herona\ns = 3*R / 2\nprint(\"Polowa obwodu s:\", s)\n\n# Wzor Herona: P = sqrt(s * (s-a) * (s-b) * (s-c))\nP = sqrt(s * (s - a) * (s - b) * (s - 2*a))\nprint(\"Wyrazenie dla pola P(a):\", P)\n\n# Szukamy maksimum - obliczamy pochodna dP/da\nfrom sympy import diff, simplify\ndP = diff(P, a)\nprint(\"Pochodna dP/da:\", simplify(dP))\n\n# Rozwiazujemy dP/da = 0\na_opt = solve(Eq(dP, 0), a)\nprint(\"Wartosci krytyczne a:\", a_opt)\n\n# Podstawiamy optymalne a do wzoru na pole\nP_max = P.subs(a, a_opt[0])\nprint(\"ODPOWIEDZ:\", simplify(P_max))\n```\n\nWAZNE: Dodawaj komentarze # tłumaczące KAZDY krok myslowy i wypisuj wyniki posrednie!",

  "executor_sympy_mc": "Napisz KOD Python/SymPy dla zadania WIELOKROTNEGO WYBORU. TYLKO KOD, BEZ TEKSTU.\n\nREGULY:\n- x**2 (NIE x^2)\n- 2*a (NIE 2a)\n- Eq(lewa, prawa) - NIGDY ==\n- Oblicz wynik I porownaj z kazdą opcją\n- print(\"ODPOWIEDZ:\", litera) gdzie litera to A/B/C/D\n\nPRZYKLAD:\n```python\nfrom sympy import *\nx = symbols('x')\nwynik = simplify((Rational(1,16))**8 * 8**16)\n# Opcje:\nopcja_A = 2**24\nopcja_B = 2**16\nopcja_C = 2**12\nopcja_D = 2**8\nif wynik == opcja_A: print(\"ODPOWIEDZ: A\")\nelif wynik == opcja_B: print(\"ODPOWIEDZ: B\")\nelif wynik == opcja_C: print(\"ODPOWIEDZ: C\")\nelif wynik == opcja_D: print(\"ODPOWIEDZ: D\")\nelse: print(\"ODPOWIEDZ:\", wynik)\n```\n\nWAZNE: Porownuj wynik z KAZDĄ opcja i wypisz LITERE (A/B/C/D).\nNapisz TYLKO blok kodu ```python bez zadnego tekstu.",

  "executor_lean": "Napisz dowod w jezyku Lean 4.\n\nREGULY:\n- Napisz TYLKO kod Lean w bloku ```lean\n- Importuj Mathlib jesli potrzebne\n- Uzyj 'sorry' dla nietrywialnych krokow\n- Format: theorem nazwa : teza := by taktyki\n- NIE dodawaj ZADNEGO tekstu przed ani po kodzie\n- NIE pisz \"Oto rozwiazanie\", \"Uwaga\", ani innych komentarzy\n\nPRZYKLAD (indukcja):\n```lean\nimport Mathlib.Data.Nat.Basic\nimport Mathlib.Algebra.BigOperators.Basic\n\ntheorem sum_first_n (n : ℕ) :\n  (Finset.range (n + 1)).sum id = n * (n + 1) / 2 := by\n  induction n with\n  | zero => simp\n  | succ k ih =>\n    rw [Finset.sum_range_succ]\n    rw [ih]\n    ring\n```\n\nPRZYKLAD (proste twierdzenie):\n```lean\ntheorem add_comm (a b : ℕ) : a + b = b + a := by\n  ring\n```\n\nWAZNE: Napisz TYLKO blok kodu ```lean bez zadnego tekstu przed ani po:\n```lean\n[kod]\n```\n\nZadnego \"Oto\", \"Uwaga\", ani innych slow!",

  "summary": "Opisz SZCZEGOLOWE rozwiazanie zadania krok po kroku. Wyjasnij PROCES ROZUMOWANIA i przepisz WSZYSTKIE wyniki posrednie z kodu.\n\nZAKAZY:\n- ZAKAZANE: $, $$, \\frac, \\sqrt, \\left, \\right, \\cdot, \\(, \\), \\[, \\], \\boxed, \\dfrac\n- Zamiast LaTeX: x**2, a/b, sqrt(x), x^2, x_1, x_2\n- NIE uzywaj znakow dolara $ w ogole\n\nFORMAT:\n\nRozwiazanie krok po kroku:\n\nKrok 1: [Nazwa kroku]\n[Wyjasnij CO robimy i DLACZEGO]\n[Przepisz wyniki posrednie z kodu]\n[Podsumuj wnioski z tego kroku]\n\nKrok 2: [Nazwa kroku]\n[Wyjasnij CO robimy i DLACZEGO]\n[Przepisz wyniki posrednie z kodu]\n[Podsumuj wnioski z tego kroku]\n\n...\n\nPodsumowanie:\n[Wyjasnij jak kroki prowadza do koncowej odpowiedzi]\n\nODPOWIEDZ: [wynik koncowy]\n\nPRZYKLAD:\nZadanie: Znajdz maksymalne pole trojkata wpisanego w okrag o promieniu R, z obwodem 3R i jednym bokiem dwukrotnie dluzszym od drugiego.\n\nWyniki z kodu:\nWyrazenie dla b: 3*R - 3*a\nPolowa obwodu s: 3*R/2\nWyrazenie dla pola P(a): sqrt((3*R/2) * (3*R/2 - a) * (3*R/2 - (3*R - 3*a)) * (3*R/2 - 2*a))\nPochodna dP/da: [wyrazenie]\nWartosci krytyczne a: [2*R/3]\nODPOWIEDZ: 2*R**2/9\n\nRozwiazanie krok po kroku:\n\nKrok 1: Wyrazenie drugiego boku przez pierwszy\nZ warunkow zadania wiemy ze c = 2a (jeden bok dwukrotnie dluzszy).\nObwod trojkata wynosi a + b + c = 3R.\nPodstawiajac c = 2a otrzymujemy: a + b + 2a = 3R, czyli 3a + b = 3R.\nStad: b = 3R - 3a\nWynik z kodu potwierdza: b = 3*R - 3*a\n\nKrok 2: Obliczenie polowy obwodu\nDo wzoru Herona potrzebujemy polowy obwodu s.\ns = (a + b + c) / 2 = 3R / 2\nWynik z kodu: s = 3*R/2\n\nKrok 3: Wyrazenie pola wzorem Herona\nWzor Herona: P = sqrt(s * (s-a) * (s-b) * (s-c))\nPodstawiajac nasze wartosci:\nP(a) = sqrt((3R/2) * (3R/2 - a) * (3R/2 - (3R - 3a)) * (3R/2 - 2a))\nOtrzymujemy funkcje pola zalezna od zmiennej a.\nWynik z kodu potwierdza to wyrazenie.\n\nKrok 4: Znajdowanie maksimum\nAby znalezc maksimum pola, obliczamy pochodna dP/da i przyrownujemy ja do zera.\nRozwiazujac rownanie dP/da = 0 znajdujemy wartosci krytyczne.\nZ kodu: a_opt = 2*R/3\nTo jest wartosc boku a, dla ktorej pole jest maksymalne.\n\nKrok 5: Obliczenie maksymalnego pola\nPodstawiamy optymalne a = 2R/3 do wzoru na pole:\nP_max = P(2R/3)\nPo uproszczeniu otrzymujemy: P_max = 2*R**2/9\n\nPodsumowanie:\nPrzez wyrazenie wszystkich bokow przez zmienna a i promien R, zastosowanie wzoru Herona oraz znalezienie maksimum funkcji P(a) poprzez obliczenie pochodnej, uzyskalismy ze maksymalne pole wynosi 2R**2/9, osiagane dla a = 2R/3, b = R, c = 4R/3.\n\nODPOWIEDZ: 2*R**2/9\n\nWAZNE: PRZEPISZ WSZYSTKIE wyniki posrednie z kodu i WYJASNIJ KAZDY krok rozumowania!",

  "formalizer_lean": "Przetlumacz dowod matematyczny na pelny formalny kod Lean 4 z biblioteka Mathlib.\n\nREGULY:\n- Napisz PELNY, działajacy kod Lean 4\n- Importuj wszystkie potrzebne moduly z Mathlib\n- Uzyj wlasciwych taktyk Lean (ring, linarith, nlinarith, field_simp, norm_num, etc.)\n- Deklaruj wszystkie zmienne z odpowiednimi typami i warunkami\n- NIE uzywaj 'sorry' - napisz pelny dowod\n- Format: theorem nazwa (zmienne : typy) (warunki : Prop) : teza := by taktyki\n\nPRZYKLAD 1 (nierownosc dla liczb naturalnych):\nDowod nieformalny: Dla n >= 1, mamy 2^n >= n+1 przez indukcje.\n\nFormalny kod Lean:\n```lean\nimport Mathlib.Data.Nat.Basic\nimport Mathlib.Tactic\n\ntheorem two_pow_ge_succ (n : ℕ) (h : n ≥ 1) : 2^n ≥ n + 1 := by\n  induction n with\n  | zero => contradiction\n  | succ k ih =>\n    by_cases hk : k = 0\n    · simp [hk]\n    · have hk_ge : k ≥ 1 := Nat.one_le_iff_ne_zero.mpr hk\n      calc 2^(k+1) = 2 * 2^k := by ring\n        _ ≥ 2 * (k + 1) := Nat.mul_le_mul_left 2 (ih hk_ge)\n        _ = 2*k + 2 := by ring\n        _ ≥ k + 2 := by linarith\n        _ = (k + 1) + 1 := by ring\n```\n\nPRZYKLAD 2 (nierownosc algebraiczna dla liczb rzeczywistych):\nDowod nieformalny: Dla x != y, mamy (x-y)^2 > 0, wiec 3(x-y)^2 > 0.\n\nFormalny kod Lean:\n```lean\nimport Mathlib.Data.Real.Basic\nimport Mathlib.Tactic\n\ntheorem square_diff_pos (x y : ℝ) (h : x ≠ y) : 3 * (x - y)^2 > 0 := by\n  have hsq : (x - y)^2 > 0 := sq_pos_of_ne_zero _ (sub_ne_zero.mpr h)\n  linarith\n```\n\nPRZYKLAD 3 (suma ciagu arytmetycznego):\nDowod nieformalny: Suma pierwszych n liczb naturalnych wynosi n(n+1)/2.\n\nFormalny kod Lean:\n```lean\nimport Mathlib.Algebra.BigOperators.Basic\nimport Mathlib.Data.Nat.Basic\nimport Mathlib.Tactic\n\nopen BigOperators\n\ntheorem sum_first_n (n : ℕ) : (Finset.range (n + 1)).sum id = n * (n + 1) / 2 := by\n  induction n with\n  | zero => simp\n  | succ k ih =>\n    rw [Finset.sum_range_succ, id.def, ih]\n    ring\n```\n\nPRZYKLAD 4 (rozwinięcie wielomianu):\nDowod nieformalny: (a+b)^2 = a^2 + 2ab + b^2\n\nFormalny kod Lean:\n```lean\nimport Mathlib.Data.Real.Basic\nimport Mathlib.Tactic\n\ntheorem binomial_square (a b : ℝ) : (a + b)^2 = a^2 + 2*a*b + b^2 := by\n  ring\n```\n\nWAZNE:\n- Uzywaj calc dla dluzszych lancuchow rownosci/nierownosci\n- Uzywaj linarith dla nierownosci liniowych\n- Uzywaj nlinarith dla nierownosci nieliniowych\n- Uzywaj ring dla upraszczania wyrazen algebraicznych\n- Uzywaj field_simp dla ulamkow\n- Deklaruj wszystkie pomocnicze lematy (have)\n- Typ ℝ dla liczb rzeczywistych, ℕ dla naturalnych, ℤ dla calkowitych\n\nNapisz TYLKO kod ```lean bez zadnego tekstu przed ani po."
}
